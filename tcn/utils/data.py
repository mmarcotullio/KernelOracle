# -*- coding: utf-8 -*-
"""data.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YfoXq7l_OeP8iwxt_vPcjHMNdi279lfO
"""

from __future__ import annotations

import json
from dataclasses import dataclass
from typing import Dict, Tuple
import numpy as np
import torch
from torch.utils.data import Dataset


@dataclass
class Vocab:
    pid_to_idx: Dict[str, int]
    idx_to_pid: Dict[int, str]
    state_to_idx: Dict[str, int]
    idx_to_state: Dict[int, str]

    @staticmethod
    def load(path: str) -> "Vocab":
        with open(path, "r") as f:
            obj = json.load(f)
        pid_to_idx = {str(k): int(v) for k, v in obj["pid_to_idx"].items()}
        idx_to_pid = {int(k): str(v) for k, v in obj["idx_to_pid"].items()}
        state_to_idx = {str(k): int(v) for k, v in obj["state_to_idx"].items()}
        idx_to_state = {int(k): str(v) for k, v in obj["idx_to_state"].items()}
        return Vocab(pid_to_idx, idx_to_pid, state_to_idx, idx_to_state)


class TraceWindowDataset(Dataset):

    def __init__(self, npz_path: str):
        data = np.load(npz_path)
        self.pid = data["pid"].astype(np.int64)
        self.cont = data["cont"].astype(np.float32)
        self.state = data["state"].astype(np.int64)
        self.y = data["y"].astype(np.int64)

        assert self.pid.shape[0] == self.y.shape[0]
        assert self.pid.shape == self.state.shape
        assert self.cont.shape[0] == self.pid.shape[0]
        assert self.cont.shape[1] == self.pid.shape[1]

    def __len__(self) -> int:
        return self.y.shape[0]

    def __getitem__(self, idx: int) -> Dict[str, torch.Tensor]:
        pid = torch.from_numpy(self.pid[idx])
        state = torch.from_numpy(self.state[idx])
        cont = torch.from_numpy(self.cont[idx])
        y = torch.tensor(self.y[idx], dtype=torch.long)


        return {"pid": pid, "state": state, "cont": cont, "y": y}


def batch_to_device(batch: Dict[str, torch.Tensor], device: torch.device) -> Dict[str, torch.Tensor]:
    return {k: v.to(device) for k, v in batch.items()}